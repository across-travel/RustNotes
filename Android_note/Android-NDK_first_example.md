---
title: Android NDK 简单示例-加法，返回字符串，返回数组；兼容性问题
date: 2016-08-02 8:08:16
category: Android_note
tag: [NDK]
toc: true
---

Android Studio 2.1 创建工程 NDKProj

## 工程结构：  
Java文件；在`SmartAlgorithm.java `中引用了JNI
```
java
`-- com
    `-- rustfisher
        `-- ndkproj
            |-- MainActivity.java
            `-- SmartAlgorithm.java
```
JNI目录，需要mk文件，头文件和源文件。这里头文件和源文件故意不统一文件名，也可实现效果。  
但还是建议用同样的文件名，方便定位。
```
jni/
|-- Android.mk
|-- Application.mk
|-- com_rustfisher_ndkproj_SmartAlgorithm.h
`-- com_rustfisher_ndkproj_SmartAlgorithm_if_not_the_same.cpp
```

加载`SmartAlgorithm`；这个是统一标示。LOCAL_MODULE 与 APP_MODULES 均为此标示。
NDK中的方法要声明为native。
```java
package com.rustfisher.ndkproj;

public class SmartAlgorithm {

    static {
        System.loadLibrary("SmartAlgorithm");
    }

    public native String getMsg();
    public native int add(int a,int b);
}
```

编写Android.mk文件；ABI 选择all，编译出支持多个平台的so文件。
填入源文件的文件名。
```
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := SmartAlgorithm
TARGET_ARCH_ABI := all
LOCAL_SRC_FILES := com_rustfisher_ndkproj_SmartAlgorithm_if_not_the_same.cpp
include $(BUILD_SHARED_LIBRARY)
```

编写Application.mk文件（网上copy来的）。同样ABI 选择all。
```
APP_PLATFORM := android-16
APP_MODULES := SmartAlgorithm
APP_ABI := all
APP_STL := stlport_static
APP_CPPFLAGS += -fexceptions
# for using c++ features,you need to enable these in your Makefile
APP_CPP_FEATURES += exceptions rtti
```

修改工程build.gradle文件，添加jni的配置。
```
    sourceSets {
        main {
            jni.srcDirs = []
            jniLibs.srcDirs = ['src/main/libs']// 指定so库的位置
        }
    }
```

编译出头文件，得到 `com_rustfisher_ndkproj_SmartAlgorithm.h`
```
Administrator@rust-PC /cygdrive/g/rust_proj/NDKProj/app/src/main/java
javah com.rustfisher.ndkproj.SmartAlgorithm
```
将头文件放到jni目录下，与源文件一起。

生成的头文件不要手动去修改，直接使用即可。
```h
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_rustfisher_ndkproj_SmartAlgorithm */

#ifndef _Included_com_rustfisher_ndkproj_SmartAlgorithm
#define _Included_com_rustfisher_ndkproj_SmartAlgorithm
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_rustfisher_ndkproj_SmartAlgorithm
 * Method:    getMsg
* Signature: ()Ljava/lang/String;
*/
JNIEXPORT jstring JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_getMsg
  (JNIEnv *, jobject);

/*
 * Class:     com_rustfisher_ndkproj_SmartAlgorithm
 * Method:    add
* Signature: (II)I
*/
JNIEXPORT jint JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_add
  (JNIEnv *, jobject, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
```

编写源文件，实现头文件中的方法。一个是返回字符串，一个是加法。
```
#include <jni.h>
#include <string.h>
#include <android/log.h>

#include "com_rustfisher_ndkproj_SmartAlgorithm.h"

/* Already define in com_rustfisher_ndkproj_SmartAlgorithm.h, no need to extern C here.
extern "C" {
    JNIEXPORT jstring JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_getMsg(JNIEnv *env, jobject obj);
    JNIEXPORT jint JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_add(JNIEnv *env, jobject obj, jint a, jint b);
};*/

JNIEXPORT jstring JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_getMsg(JNIEnv *env, jobject obj) {

    return env->NewStringUTF("Hello from the JNI.");
}

JNIEXPORT jint JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_add(JNIEnv *env, jobject obj, jint a, jint b) {
    return a + b;
}//*
```

然后在命令行 ndk-build。这里是win7下的Cygwin。
```
Administrator@rust-PC /cygdrive/g/rust_proj/NDKProj/app/src/main/jni
$ ndk-build.cmd
[all] Compile++      : SmartAlgorithm <= com_rustfisher_ndkproj_SmartAlgorithm_if_not_the_same.cpp
[all] SharedLibrary  : libSmartAlgorithm.so
[all] Install        : libSmartAlgorithm.so => libs/arm64-v8a/libSmartAlgorithm.so
# ...... 后面还有很多
```

在libs目录下出现了对应的so库
```
Administrator@rust-PC /cygdrive/g/rust_proj/NDKProj/app/src/main/libs
$ tree
.
|-- arm64-v8a
|   `-- libSmartAlgorithm.so
|-- armeabi
|   `-- libSmartAlgorithm.so
|-- armeabi-v7a
|   `-- libSmartAlgorithm.so
|-- mips
|   `-- libSmartAlgorithm.so
|-- mips64
|   `-- libSmartAlgorithm.so
|-- x86
|   `-- libSmartAlgorithm.so
`-- x86_64
    `-- libSmartAlgorithm.so

7 directories, 7 files
```
在MainActivity中调用这两个方法。  
运行apk到机器上，查看log。发现调用成功。

```
com.rustfisher.ndkproj D/MainActivity: onCreate: Hello from the JNI.
com.rustfisher.ndkproj D/MainActivity: onCreate: 3
```

### 处理数组的方法  

1.不要直接操作输入的数组；  
2.注意释放本地引用，防止溢出。  
```java
public native short[] getConvertedArray(short[] data, int dataLen);
```

```cpp
JNIEXPORT jshortArray JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_getConvertedArray(JNIEnv *env, jobject obj, jshortArray input, jint len) {
    jshort* inputPtr;
    inputPtr = env->GetShortArrayElements(input,0);// 直接操作指针会改变Android Dalvik中的值
    jshort* resPtr;
    jshortArray result;
    result = env->NewShortArray(len);// 创建新的数组
    resPtr = env->GetShortArrayElements(result,0);// 指针

    for(jint i = 0;i < len;i++) {
        resPtr[i] = inputPtr[i] * 2;
    }
    env->ReleaseShortArrayElements(input, inputPtr, 0);// 释放本地引用
    env->SetShortArrayRegion(result,0,len,resPtr);
    env->ReleaseShortArrayElements(result, resPtr, 0);// 释放本地引用
    return result;// 返回结果
}
```

### NDK兼容性问题
Vivo x6plus 兼容性问题。Vivo x6plus 打开Parrot界面即崩溃。但是Parrot官方APP能够正常使用。    
我自己的so库与Parrot的so库不兼容，出现

```
java.lang.UnsatisfiedLinkError:
dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.xx.xx.xxx-1/base.apk"],nativeLibraryDirectories=[/data/app/com.xx.xx.xxx-1/lib/arm64, /vendor/lib64, /system/lib64]]] couldn't find "libjson.so"
    at java.lang.Runtime.loadLibrary(Runtime.java:366)
    at java.lang.System.loadLibrary(System.java:988)
    at com.parrot.arsdk.ARSDK.loadSDKLibs(ARSDK.java:20)
    at com.parrot.sdk.activity.DronesListActivity.<clinit>(DronesListActivity.java:44)
    at java.lang.reflect.Constructor.newInstance(Native Method)
```

#### 分析处理兼容性问题

将Parrot官方apk解包后，找到so库文件。发现只有x86、mips、armeabi_v7a、armeabi 这4个。
而我加载了有更多的库。

将我自己的so文件删除至只剩下Parrot那4个即可。

Android.mk  
`TARGET_ARCH_ABI := x86 mips armeabi armeabi-v7a`
